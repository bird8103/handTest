<!DOCTYPE html>
<html  lang="ja">
    <head>
        <meta charset="UTF-8">
        <title>テスト用画面</title>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
        <style>
          video {
            transform: scaleX(-1);
            -webkit-transform: scaleX(-1);
          }
        </style>
    </head>
    <body>
        <div class="container">
            <!-- Webカメラの映像（入力） -->
            <video id="input"></video>
            <!--  認識した手の形状を可視化した映像（出力）  -->
            <canvas id="output" width="600" height="600"></canvas>
        </div>
        <button id="start">start</button>
        <button id="stop">stop</button>
        <p id="poit_data"></p>
    </body> 
</html>
<script defer>
    const video = document.getElementById('input');
    const canvas = document.getElementById('output');
    const ctx = canvas.getContext('2d');

    const flipCanvas = document.createElement('canvas');
    flipCanvas.width = 600;
    flipCanvas.height = 600;
    const flipCtx = flipCanvas.getContext('2d');

    const display_p = document.getElementById('poit_data');
    let finalString = "";
    let hitosashi_x = 0.0;
    let hitosashi_y = 0.0;
    let oya_z = 0.0;
    let flick_flag = 0; // 1で上へ-1で下へ
    let flick_point = 0;
    let flick_start_y = 0;
    let flick_before_y = 0;
    let flick_cooldown = 0;
    
    //関連ファイルの読み込み
    const config = {
      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    };
    const hands = new Hands(config);

    //カメラからの映像をhands.jsで使えるようにする
    const camera = new Camera(video, {
      onFrame: async () => {
        if (flick_cooldown!=0){
          if (flick_cooldown>=1){
            flick_cooldown-=1
          }else if (flick_cooldown<=-1){
            flick_cooldown+=1
          };
        }
        // 左右反転して描画
        flipCtx.save();
        flipCtx.scale(-1, 1); // 水平方向に反転
        flipCtx.drawImage(video, -flipCanvas.width, 0, flipCanvas.width, flipCanvas.height);
        flipCtx.restore();
        // Mediapipe に反転済み画像を渡す
        await hands.send({ image: flipCanvas });
      },
      width: 600,
      height: 600
    });

    hands.setOptions({
        maxNumHands: 1,              //検出する手の最大数
        modelComplexity: 1,          //ランドマーク検出精度(0か1)
        minDetectionConfidence: 0.5, //手を検出するための信頼値(0.0~1.0)
        minTrackingConfidence: 0.5   //ランドマーク追跡の信頼度(0.0~1.0)
    });

    //形状認識した結果の取得
    hands.onResults(results => {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.drawImage(results.image,0,0,canvas.width,canvas.height);
      //console.log(results);
      
      if(results.multiHandLandmarks) {
        results.multiHandLandmarks.forEach(marks => {
          // 緑色の線で骨組みを可視化
          drawConnectors(ctx, marks, HAND_CONNECTIONS, {color: '#0f0'});
          // 赤色でランドマークを可視化
          drawLandmarks(ctx, marks, {color: '#f00'});

          finalString = "";
          hitosashi_x = Math.round(marks[8]["x"]*100)/100;
          hitosashi_y = Math.round(marks[8]["y"]*100)/100;
          oya_z = Math.round(marks[4]["z"]*100)/100;

          // フリックテスト
          finalString += "フリッククールダウン"
          if (flick_cooldown>=1){finalString+="(上)";}
          if (flick_cooldown<=-1){finalString+="(下)";}
          finalString+=flick_cooldown+"<br>"

          if (flick_cooldown==0){
            if (flick_flag==0){
              if ((hitosashi_y<flick_before_y)&&(flick_before_y-hitosashi_y>=0.15)){
                flick_flag=1;
              }else if ((hitosashi_y>flick_before_y)&&(hitosashi_y-flick_before_y>=0.25)){
                flick_flag=-1;
              }
            }else if (flick_flag==1){
              if (hitosashi_y<flick_before_y){
                flick_point+=1;
              }else{
                flick_flag=0;
                flick_point=0;
                flick_cooldown=0;
              }
              if (flick_point>=3){
                flick_flag=0;
                flick_point=0;
                flick_cooldown=30;
              }
            }else if (flick_flag==-1){
              if (flick_before_y<hitosashi_y){
                flick_point+=1;
              }else{
                flick_flag=0;
                flick_point=0;
                flick_cooldown=0;
              }
              if (flick_point>=2){
                flick_flag=0;
                flick_point=0;
                flick_cooldown=-30;
              }
            }
          }
          flick_before_y=hitosashi_y;

          finalString += "人差し指x="+hitosashi_x+"<br>";
          finalString += "人差し指y="+hitosashi_y+"<br>";
          finalString += "親指z="+oya_z+"<br>";

          display_p.innerHTML=finalString;
        })
      }
    });

    document.getElementById('start')
      .addEventListener('click', () => camera.start());
    document.getElementById('stop')
      .addEventListener('click', () =>  camera.stop());
</script>
